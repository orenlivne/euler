#!/bin/bash
#--------------------------------------------------------------------
# Load Katie's EVE ethnicity file into database where the annotation
# table from Raphael exists.
#
# Input: Katie EVE ethnicity file, database table (matches output
# file name).
#
# Author: Oren E. Livne
# Date:   09-SEP-2013
#--------------------------------------------------------------------

#=======================================
# Read input parameters
#=======================================
DARGS=65
PROGNAME=`basename $0`

function read_input_args
{
    #%%%%%%%%%%%%%%%%%%%%%%%%
    # Default argument values
    #%%%%%%%%%%%%%%%%%%%%%%%%
    # Chunk Size [# lines]
    chunk_size=2000000
    # MySQL connection information
    db_user="ucsc"
    db_password="ucsc"
    db_host="localhost"
    db_database="ucsc"

    # Read input arguments
    while getopts "hc:u:p:l:d:" optionName; do
	case "$optionName" in
	    c) chunk_size="$OPTARG";;
	    u) db_user="$OPTARG";;
	    p) db_password="$OPTARG";;
	    l) db_host="$OPTARG";;
	    d) db_database="$OPTARG";;
	    h) print_usage; exit 0;;
	    [?]) print_type_for_help;;
       esac
    done

    # Get mandatory arguments
    shift $(( $OPTIND -1 ))
    if [[ $# -ne 2 ]]; then
	echo "Input file, out-name must be specified."
	print_type_for_help
    fi

    #---------------------
    # Mandatory arguments
    #---------------------
    # Katie's EVE ethnicity text input file
    in_file="$1"
    # Database name and output file name
    table="$2"
    
    # Set database command line prefix. Global to this file.
    DB_CMD="mysql -A -h ${db_host} -u ${db_user} -p${db_password} ${db_database}"
}

function print_usage
{
    echo -e "Usage: ${PROGNAME} <in-file> <out-name>"
    echo -e ""
    echo -e "Load Katie's EVE ethnicity file into database where the annotation"
    echo -e "table from Raphael exists. Input: Katie EVE ethnicity file, database table"
    echo -e "(matches output file name)."
    echo -e ""
    echo -e "Optional flags:"
    echo -e "\t-c chunk-size\tNumber of lines in an input file chunk to be queried against the database. Default: ${chunk_size}"
    echo -e "\t-u user\tMySQL database user name. ${db_user}."
    echo -e "\t-p password\tMySQL database user name. ${db_password}."
    echo -e "\t-l host\tMySQL database user name. ${db_host}."
    echo -e "\t-d database\tMySQL database name. ${db_database}."
}

# Print help message and die
function print_type_for_help
{
    echo "Type \"${PROGNAME} -h\" for help."
    exit $E_BADARGS
}

#=======================================
# Business Logic
#=======================================

# Create SQL script that creates a table for Katie's EVE data and load the
# input text file into the table.
function create_sql_script
{
    in_file="$1"
    table="$2"
    sql_file="$3"
    cat <<EOF > ${sql_file}
drop table if exists ${table};

create table ${table}
(
  record_id INT AUTO_INCREMENT PRIMARY KEY,
  chrom CHAR(2),
  snp_id INT,
  cm FLOAT,
  pos INT,
  A1 CHAR(1),
  A2 CHAR(1),
  maf FLOAT,
  is_exome BOOL,
  exome_probe_id CHAR(25),
  INDEX name (chrom, pos)
);

# Load all columns from file except record_id, which will automatically be generated by MySQL upon loading.
LOAD DATA LOCAL INFILE '${in_file}' INTO TABLE ${table} (chrom,snp_id,cm,pos,A1,A2,maf,is_exome,exome_probe_id);
EOF
}

# Clean input file: convert NA to NULL
function create_clean_file
{
    in_file="$1"

    echo "Converting ${in_file} to clean form ..."
    awk '{ for (i = 1; i <= NF; i++) { if (i == 8) { if ($i == "NA") { printf "\t0"; } else { printf "\t1"; } } else { if (i > 1) { printf "\t"; } if ($i == "NA") { printf "NULL"; } else { printf "%s", $i; } } } printf "\n"; }' ${in_file} > ${in_file}.clean
}  

# Create database table. Load input file into database.
function load_file_to_db
{
    in_file="$1"
    table="$2"

    sql=`mktemp`
    create_sql_script $( readlink -f ${in_file} ) ${table} ${sql}

    echo "  Loading file ${in_file} into database ..."
    cat ${sql} | ${DB_CMD}
    rm -f ${sql}

    # Print a report
    echo "  `${DB_CMD} -B -e \"select count(*) from ${table}\" | sed '1d'` rows loaded."
}

# Join Katie's data with the annotation table. Several selected annotation columns by Katie are returned.
function query_snps
{
  table="$1"
  limit="$2"
  ${DB_CMD} -e "select e.*, a.vtools_id, a.dbSNP_name,a.region_type,a.mut_type,a.dbSNP_class,a.dbSNP_func,a.Polyphen2_HDIV_score,a.GERP_RS,a.refGene2 from ${table} e join eve_annotation a on e.chrom = a.chrom and a.pos = e.pos where a.region_type in ('exonic', 'exonic;splicing', 'splicing')"
}

#=======================================
# Main Program
#=======================================
# Parse CLI arguments
read_input_args "$@"
out_file="${table}.out"

if [ ! -f ${in_file}.clean ]; then
    create_clean_file ${in_file}
fi

# Chunk the input file into managable sizes to avoid out-of-memory problems.
# Query for annotations of each chunk; merge results into out_file.
split_dir=`mktemp -d`
rm -f ${out_file}
split -d -l ${chunk_size} ${in_file}.clean ${split_dir}/part
chunk_num=0
num_chunks=`ls -1 ${split_dir} | wc -l`
for chunk in `ls -1 ${split_dir} | sort -n`; do
    chunk_num=$(( $chunk_num + 1 ))
    printf "Processing chunk %d/%d ...\n" ${chunk_num} ${num_chunks}
    chunk_file="${split_dir}/${chunk}"
    this_chunk_size=`wc -l ${chunk_file} | awk '{print $1}'`
    load_file_to_db ${chunk_file} ${table}
    # Run query; delete header line from output
    echo "  Querying ..."
    query_snps ${table} ${this_chunk_size} | sed '1d' >> ${out_file}
done
rm -rf ${split_dir}

# Transfer the file to CRI permanent storage
rsync -auvP ${out_file} olivne@bios.cri.uchicago.edu:/group/ober-resources/users/olivne/annotations/
