'''
============================================================
http://projecteuler.net/problem=29

Consider all integer combinations of a^b for 2  a  5 and 2  b  5:

22=4, 23=8, 24=16, 25=32
32=9, 33=27, 34=81, 35=243
42=16, 43=64, 44=256, 45=1024
52=25, 53=125, 54=625, 55=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2  a  100 and 2  b  100?
============================================================
'''
import numpy as np

def distinct_powers(n):
    '''Number of distinct powers a^b for 2 <= a,b <= 100.
    n >= 2 and not too large to avoid overflow.'''
    sq, logn = int(np.floor(n ** 0.5)) + 1, np.log(n)
    print sq
    d = {}           # Dictionary of c-to-min-k
    for c, k in ((a ** k, k) for a in xrange(2, sq) for k in xrange(2, 1 + int(np.floor(1e-15 + logn / np.log(a))))):
        print c, k
        kmin = d.setdefault(c, k)
        if k < kmin:
            d[c] = k
    print d
    print map(lambda k: n / k - 1, d.itervalues())
    return (n - 1) ** 2 - sum(map(lambda k: n / k - 1, d.itervalues()))

def distinct_powers_brute_force(n):
    return len(set(a ** b for a in xrange(2, n + 1) for b in xrange(2, n + 1)))

if __name__ == "__main__":
#    import doctest
#    doctest.testmod()
    print distinct_powers(8)
    print distinct_powers_brute_force(8)
    
    n = 8
    print np.reshape([a ** b for a in xrange(2, n + 1) for b in xrange(2, n + 1)], (n - 1, n - 1))
