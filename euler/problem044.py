'''
============================================================
http://projecteuler.net/problem=44

Pentagonal numbers are generated by the formula, Pn=n(3n1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70  22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk  Pj| is minimised; what is the value of D?
============================================================
'''
import math

def is_pentagonal(m):
    '''Is m a pentagonal number or not.'''
    n = (1.0 + math.sqrt(1 + 24 * m)) / 6
    return n - math.floor(n) < 1e-15

'''Pentagonal number number n.'''
p = lambda n : n * (3 * n - 1) / 2  # OK to divide - order of operations!

def find_min(limit=1000, max_iter=5):
    '''Return the minimum D in the specified range of (j,k) pairs.'''
    for _ in xrange(max_iter):
        D = find_min_up_to(limit)
        if D > 0:
            return D
        limit *= 2
    raise ValueError('Did not find any pairs')

def find_min_up_to(limit):
    '''Return the minimum D for j <= limit.'''
    D = -1
    #print 'limit', limit
    for s in xrange(1, limit + 1):  # Unclear what the upper limit of this loop should really be
        #print 's', s
        found = False
        for j in xrange(1, limit + 1):
            pj, pk = p(j), p(j + s)
            # print j, j + s, pj, pk, pk - pj, pk + pj
            d = pk - pj
            if D > 0 and d > D:
                # No feasible pairs in s-range
                break
            else:
                # print 'found at j', j
                found = True
                if is_pentagonal(d) and is_pentagonal(pk + pj) and (d < D or D < 0):
                    #print 'Found pair', j, j + s, d
                    D = d
        if not found:
            break
    return D 

def find_min_brute_force(limit):
    '''Return the minimum D for j,k <= limit.'''
    D = -1
    for j in xrange(1, limit + 1):
        for k in xrange(j + 1, limit + 1):
            pj, pk = p(j), p(k)
            # print j, j + s, pj, pk, pk - pj, pk + pj
            d = pk - pj
            if (d < D or D < 0) and is_pentagonal(d) and is_pentagonal(pk + pj):
                print 'Found pair', j, k, d
                D = d
    return D

if __name__ == "__main__":
#    import doctest
#    doctest.testmod()
    print find_min_brute_force(10000)
    print find_min(10000, 5)
