'''
============================================================
http://projecteuler.net/problem=8

Find the greatest product of five consecutive digits in the 1000-digit number.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Created on Feb 21, 2013
@author: Oren Livne <livne@uchicago.edu>
============================================================
'''
import numpy as np

def max_prod(it, sz):
    '''Find the greatest product of sz consecutive digits in the digit stream it.

    >>> max_prod((int(x) for x in '73167176531330624919225119674426574742355349194934' \
'96983520312774506326239578318016984801869478851843' \
'85861560789112949495459501737958331952853208805511' \
'12540698747158523863050715693290963295227443043557' \
'66896648950445244523161731856403098711121722383113' \
'62229893423380308135336276614282806444486645238749' \
'30358907296290491560440772390713810515859307960866' \
'70172427121883998797908792274921901699720888093776' \
'65727333001053367881220235421809751254540594752243' \
'52584907711670556013604839586446706324415722155397' \
'53697817977846174064955149290862569321978468622482' \
'83972241375657056057490261407972968652414535100474' \
'82166370484403199890008895243450658541227588666881' \
'16427171479924442928230863465674813919123162824586' \
'17866458359124566529476545682848912883142607690042' \
'24219022671055626321111109370544217506941658960408' \
'07198403850962455444362981230987879927244284909188' \
'84580156166097919133875499200524063689912560717606' \
'05886116467109405077541002256983155200055935729725' \
'71636269561882670428252483600823257530420752963450'), 5)
    40824
    '''
    # Populate initial window
    #count = 0
    p, zeros, w = 1, 0, [None] * sz
    for i in xrange(sz):
        x = it.next()
        w[i] = x
        if x == 0:
            zeros += 1
        else:
            p *= x
            #count += 1
    pmax = p

    # Sliding window - remove first, add last
    # Rotate insertion index j cyclically in w
    while True:
        i += 1
        j = i % sz
        
        # Remove first
        first = w[j]
        if first == 0:
            zeros -= 1
        else:
            p /= first
            #count += 1
            
        # Insert last
        try:
            last = it.next()
        except StopIteration:
            break
        w[j] = last
        if last == 0:
            zeros += 1
        else:
            p *= last
            #count += 1
            
        # Update max product if no zeros in window
        if not zeros and p > pmax:
            pmax = p
    return pmax#, count

def max_prod_Steendor(it, sz):
    '''Find the greatest product of sz consecutive digits in the digit stream it.
    Using Steendor''s implementation from the Euler Problem 8 Thread, 01 Dec 2005 05:26 pm.
    
    Reduces # multiplications from 1803 to 1440.

    >>> max_prod_Steendor((int(x) for x in '73167176531330624919225119674426574742355349194934' \
'96983520312774506326239578318016984801869478851843' \
'85861560789112949495459501737958331952853208805511' \
'12540698747158523863050715693290963295227443043557' \
'66896648950445244523161731856403098711121722383113' \
'62229893423380308135336276614282806444486645238749' \
'30358907296290491560440772390713810515859307960866' \
'70172427121883998797908792274921901699720888093776' \
'65727333001053367881220235421809751254540594752243' \
'52584907711670556013604839586446706324415722155397' \
'53697817977846174064955149290862569321978468622482' \
'83972241375657056057490261407972968652414535100474' \
'82166370484403199890008895243450658541227588666881' \
'16427171479924442928230863465674813919123162824586' \
'17866458359124566529476545682848912883142607690042' \
'24219022671055626321111109370544217506941658960408' \
'07198403850962455444362981230987879927244284909188' \
'84580156166097919133875499200524063689912560717606' \
'05886116467109405077541002256983155200055935729725' \
'71636269561882670428252483600823257530420752963450'), 5)
    40824
    '''
    # Populate initial window
    #count = 0
    p, zeros, w = 1, 0, [None] * sz
    for i in xrange(sz):
        x = it.next()
        w[i] = x
        if x == 0:
            zeros += 1
        else:
            p *= x
            #count += 1
    pmax = p

    # Sliding window - remove first, add last
    # Rotate insertion index j cyclically in w
    eof = False
    while True:
        first, last = 0, 0
        while last <= first or zeros:
            i += 1
            j = i % sz
            # Remove first
            first = w[j]
            if first == 0:
                zeros -= 1
                
            # Insert last
            try:
                last = it.next()
            except StopIteration:
                eof = True
                break
            w[j] = last
            if last == 0:
                zeros += 1
        
        if eof:
            break
        # Update max product
        p = np.product(w)
        #count += sz 
        if p > pmax:
            pmax = p
    return pmax#, count

if __name__ == "__main__":
    import doctest
    doctest.testmod()
