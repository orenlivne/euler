'''
============================================================
http://projecteuler.net/problem=61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle         P3,n=n(n+1)/2         1, 3, 6, 10, 15, ...
Square         P4,n=n2         1, 4, 9, 16, 25, ...
Pentagonal         P5,n=n(3n1)/2         1, 5, 12, 22, 35, ...
Hexagonal         P6,n=n(2n1)         1, 6, 15, 28, 45, ...
Heptagonal         P7,n=n(5n3)/2         1, 7, 18, 34, 55, ...
Octagonal         P8,n=n(3n2)         1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
============================================================
'''
from math import ceil

def cyclic_polygoal_sum(K, s, d):
    '''Return the sum of a d-digit, s-cyclic polygonal squence of length K>=3. Assumes such a
    sequence exists.'''
    # Initial condition (k=1)
    # S = solution dictionary. Indexed by suffix. Note: keys are strings.
    # A = polygonals, indexed by k (polygonal seris index) and prefix. Note: keys are strings. 
    KP, p_min, p_max = K + 1, 10 ** (d - 1), 10 ** d - 1  # [p_min,p_max) = range of d-digit numbers
    S, A, all_k = {}, [{} for _ in xrange(KP)], set(range(3, KP))
    for k in xrange(3, KP):
        for p in p_range(k, p_min, p_max):
            S.setdefault(suffix(p, s), set([])).add(((p,), (k,)))
            A[k].setdefault(prefix(p, s), set([])).add(p)
    
    # Dynamic programming k=2,3,...,K. T = solutions of length k. S = solutions of length k-1
    for k in xrange(K - 3):
        T = {}
        for suf, (a, L) in ((suf, sol) for suf, solutions in S.iteritems() for sol in solutions):
            # For each (k-1)-length solution (a=sequence, L=set of corresponding k-labels)...
            for l in (l for l in all_k - set(L) if A[l].has_key(suf)):
                for b in A[l][suf]:
                    # ... append all polygonals whose prefix matches a's suffix and whose k is
                    # not yet in L. Re-index in T using the new solution's suffix
                    T.setdefault(suffix(b, s), set([])).add((a + (b,), L + (l,)))
        S = T
    # Return the first iterate. If the solution is unique, this is -the- solution.
    solutions = filter(lambda a: suffix(a[-1], s) == prefix(a[0], s), 
                       (sol[0] for solutions in S.itervalues() for sol in solutions))
    return solutions[0], sum(solutions[0])

# n for which P(k,n)=p
np = lambda k, p: (((8 * k - 16) * p + (k - 4) * (k - 4)) ** 0.5 + k - 4) / (2 * k - 4)

def p_range(k, p_min, p_max):
    '''Return the range of k-goals in [p_min,p_max].'''
    return ((k - 2) * n * (n - 1) / 2 + n for n in xrange(int(ceil(np(k, p_min))), int(np(k, p_max)) + 1))

suffix = lambda a, s: str(a)[-s:]
prefix = lambda a, s: str(a)[:s]

if __name__ == "__main__":
#    import doctest
#    doctest.testmod()
    print cyclic_polygoal_sum(5, 2, 4)
    print cyclic_polygoal_sum(8, 2, 4)
