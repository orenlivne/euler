'''
============================================================
http://projecteuler.net/problem=12

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Created on Feb 21, 2013
@author: Oren Livne <livne@uchicago.edu>
============================================================
'''
import numpy as np
from euler.problem007 import primes_in_range
from collections import OrderedDict

def smallest_tri(d):
    '''Smallest triangle number T_n with > d divisors. Works for all d >= 0.
    
    >>> smallest_tri(4)
    28
    
    >>> smallest_tri(5)
    28
    
    >>> smallest_tri(500)
    76576500
    '''
    n, fac_n, g = 2, {}, 0
    while g <= d:
        fac_np = factorize(n)
        # Prime factorization of T_{n-1}. Note: the two dictionaries of n, n+1 have disjoint key sets.
        fac = dict(fac_n.items() + fac_np.items())
        # Divide by 2 (T_n = n(n+1)/2)
        if fac[2] == 1: del fac[2]
        else: fac[2] = fac[2] - 1
        g = np.product([(k + 1) for k in fac.itervalues()])  # Number of divisors
        # Increment to next triangle number
        fac_n = fac_np
        n += 1
    return (n - 2) * (n - 1) / 2  # Return T_n. We're already at n+2 here.

def factorize(n, primes=None):
    '''Factorize n >= 1 into primes. Caches the prime list using a Primes() singleton.'''
    d = OrderedDict()
    if n == 1: return d
    for p in (primes if primes is not None else Primes()):
        count = 0
        while n != 1 and n % p == 0:
            count += 1
            n /= p
        if count: d[p] = count
        if n == 1: return d

class Primes(object):
    '''An iterator of primes.'''
    _primes, _nmin, _nmax = np.array([], np.int), 2, 100  # Global prime list. We assume a single-threaded implementation and don't lock/synchronize these global variables
    
    def __init__(self):
        self._count = 0
        
    def __iter__(self):
        return self
    
    def next(self):  # @ReservedAssignment
        p = Primes._primes
        self._count += 1
        if not p.size or len(p) < self._count:
            Primes._primes = np.append(p, primes_in_range(Primes._nmin, Primes._nmax, p))
            Primes._nmin = Primes._nmax
            Primes._nmax = 2 * Primes._nmin
        return Primes._primes[self._count - 1]

if __name__ == "__main__":
    import doctest
    doctest.testmod()
